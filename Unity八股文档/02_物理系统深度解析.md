# Unity物理系统深度解析

## 目录
1. [物理系统架构](#物理系统架构)
2. [3D物理系统详解](#3d物理系统详解)
3. [2D物理系统详解](#2d物理系统详解)
4. [碰撞检测原理](#碰撞检测原理)
5. [物理优化策略](#物理优化策略)
6. [常见面试问题](#常见面试问题)

---

## 物理系统架构

### Unity物理引擎概述
```
Unity物理系统基于两个主要引擎：
├── 3D物理：PhysX 3.4 (NVIDIA)
│   ├── 高精度碰撞检测
│   ├── 复杂形状支持
│   └── 多线程优化
└── 2D物理：Box2D (Erin Catto)
    ├── 轻量级设计
    ├── 优秀的性能表现
    └── 专为2D游戏优化
```

### 物理系统更新流程
```csharp
// Unity物理系统的更新时序
void PhysicsUpdateLoop()
{
    // 1. Fixed Timestep更新
    while (accumulatedTime >= fixedDeltaTime)
    {
        // 2. 输入处理
        ProcessUserInput();
        
        // 3. FixedUpdate调用
        CallFixedUpdate();
        
        // 4. 物理模拟
        Physics.Simulate(fixedDeltaTime);
        
        // 5. 碰撞事件分发
        DispatchCollisionEvents();
        
        accumulatedTime -= fixedDeltaTime;
    }
    
    // 6. 插值更新（渲染帧）
    InterpolateTransforms();
}
```

---

## 3D物理系统详解

### 核心组件架构
```csharp
// 3D物理组件层次结构
GameObject
├── Rigidbody (刚体)
│   ├── mass (质量)
│   ├── drag (线性阻尼)
│   ├── angularDrag (角阻尼)
│   ├── useGravity (使用重力)
│   ├── isKinematic (运动学模式)
│   └── constraints (约束)
├── Collider (碰撞器)
│   ├── BoxCollider (盒碰撞器)
│   ├── SphereCollider (球碰撞器)
│   ├── CapsuleCollider (胶囊碰撞器)
│   ├── MeshCollider (网格碰撞器)
│   └── WheelCollider (轮子碰撞器)
└── Joints (关节)
    ├── FixedJoint (固定关节)
    ├── HingeJoint (铰链关节)
    ├── SpringJoint (弹簧关节)
    └── ConfigurableJoint (可配置关节)
```

### Rigidbody深度解析

#### 1. 物理状态模式
```csharp
public enum RigidbodyMode
{
    Dynamic,    // 动态：受力和碰撞影响
    Kinematic,  // 运动学：不受力影响，但影响其他物体
    Static      // 静态：完全不动，优化性能
}

public class RigidbodyController : MonoBehaviour
{
    private Rigidbody rb;
    
    void Start()
    {
        rb = GetComponent<Rigidbody>();
        
        // 动态物体设置
        rb.mass = 1.0f;
        rb.drag = 0.1f;
        rb.angularDrag = 0.05f;
        rb.useGravity = true;
        rb.isKinematic = false;
    }
    
    // 力的应用方式
    void ApplyForces()
    {
        // 1. 持续力（如推力）
        rb.AddForce(Vector3.forward * 10f);
        
        // 2. 冲量（瞬间力）
        rb.AddForce(Vector3.up * 300f, ForceMode.Impulse);
        
        // 3. 加速度（忽略质量）
        rb.AddForce(Vector3.right * 5f, ForceMode.Acceleration);
        
        // 4. 速度变化（忽略质量的冲量）
        rb.AddForce(Vector3.left * 10f, ForceMode.VelocityChange);
    }
    
    // 扭矩应用
    void ApplyTorque()
    {
        // 旋转力
        rb.AddTorque(Vector3.up * 50f);
        
        // 在特定点施加力（产生扭矩）
        rb.AddForceAtPosition(Vector3.forward * 100f, transform.position + Vector3.up);
    }
}
```

#### 2. 质量和惯性
```csharp
public class MassAndInertia : MonoBehaviour
{
    private Rigidbody rb;
    
    void Start()
    {
        rb = GetComponent<Rigidbody>();
        
        // 自动计算惯性张量（基于碰撞器）
        rb.ResetInertiaTensor();
        
        // 手动设置惯性张量
        rb.inertiaTensor = new Vector3(1f, 1f, 1f);
        rb.inertiaTensorRotation = Quaternion.identity;
        
        // 质心设置
        rb.centerOfMass = Vector3.zero;
    }
    
    // 惯性张量计算原理
    Matrix3x3 CalculateInertiaTensor(Mesh mesh, float density)
    {
        Matrix3x3 inertia = Matrix3x3.zero;
        
        // 对于每个三角形计算贡献
        for (int i = 0; i < mesh.triangles.Length; i += 3)
        {
            Vector3 v0 = mesh.vertices[mesh.triangles[i]];
            Vector3 v1 = mesh.vertices[mesh.triangles[i + 1]];
            Vector3 v2 = mesh.vertices[mesh.triangles[i + 2]];
            
            // 计算三角形的惯性贡献
            Matrix3x3 triangleInertia = CalculateTriangleInertia(v0, v1, v2, density);
            inertia += triangleInertia;
        }
        
        return inertia;
    }
}
```

### 碰撞器详解

#### 1. 原始碰撞器
```csharp
public class PrimitiveColliders : MonoBehaviour
{
    void Start()
    {
        // 盒碰撞器 - 最高效
        BoxCollider box = gameObject.AddComponent<BoxCollider>();
        box.center = Vector3.zero;
        box.size = Vector3.one;
        
        // 球碰撞器 - 旋转无关
        SphereCollider sphere = gameObject.AddComponent<SphereCollider>();
        sphere.center = Vector3.zero;
        sphere.radius = 0.5f;
        
        // 胶囊碰撞器 - 角色控制器常用
        CapsuleCollider capsule = gameObject.AddComponent<CapsuleCollider>();
        capsule.center = Vector3.zero;
        capsule.radius = 0.5f;
        capsule.height = 2f;
        capsule.direction = 1; // Y轴方向
    }
}
```

#### 2. 网格碰撞器
```csharp
public class MeshColliderSetup : MonoBehaviour
{
    void Start()
    {
        MeshCollider meshCollider = gameObject.AddComponent<MeshCollider>();
        
        // 凸包模式：可以是动态刚体
        meshCollider.convex = true;
        
        // 非凸包模式：只能是静态或运动学刚体
        meshCollider.convex = false;
        
        // 网格简化
        SimplifyMeshForCollision();
    }
    
    void SimplifyMeshForCollision()
    {
        Mesh originalMesh = GetComponent<MeshFilter>().mesh;
        
        // 创建简化的碰撞网格
        Mesh collisionMesh = new Mesh();
        
        // 降低顶点数量
        Vector3[] simplifiedVertices = ReduceVertices(originalMesh.vertices);
        int[] simplifiedTriangles = RegenerateTriangles(simplifiedVertices);
        
        collisionMesh.vertices = simplifiedVertices;
        collisionMesh.triangles = simplifiedTriangles;
        collisionMesh.RecalculateNormals();
        
        GetComponent<MeshCollider>().sharedMesh = collisionMesh;
    }
}
```

### 关节系统

#### 1. 铰链关节
```csharp
public class HingeJointSetup : MonoBehaviour
{
    void Start()
    {
        HingeJoint hinge = gameObject.AddComponent<HingeJoint>();
        
        // 连接到另一个刚体
        hinge.connectedBody = GetConnectedRigidbody();
        
        // 设置旋转轴
        hinge.axis = Vector3.right;
        
        // 设置锚点
        hinge.anchor = Vector3.zero;
        hinge.connectedAnchor = Vector3.zero;
        
        // 角度限制
        hinge.useLimits = true;
        JointLimits limits = hinge.limits;
        limits.min = -90f;
        limits.max = 90f;
        limits.bounciness = 0.1f;
        hinge.limits = limits;
        
        // 弹簧设置
        hinge.useSpring = true;
        JointSpring spring = hinge.spring;
        spring.spring = 100f;        // 弹簧强度
        spring.damper = 10f;         // 阻尼
        spring.targetPosition = 0f;  // 目标位置
        hinge.spring = spring;
        
        // 马达设置
        hinge.useMotor = true;
        JointMotor motor = hinge.motor;
        motor.targetVelocity = 90f;  // 目标角速度
        motor.force = 100f;          // 马达力
        motor.freeSpin = false;      // 是否自由旋转
        hinge.motor = motor;
    }
}
```

#### 2. 可配置关节
```csharp
public class ConfigurableJointAdvanced : MonoBehaviour
{
    void Start()
    {
        ConfigurableJoint joint = gameObject.AddComponent<ConfigurableJoint>();
        
        // 位移约束
        joint.xMotion = ConfigurableJointMotion.Locked;    // X轴锁定
        joint.yMotion = ConfigurableJointMotion.Limited;   // Y轴限制
        joint.zMotion = ConfigurableJointMotion.Free;      // Z轴自由
        
        // 旋转约束
        joint.angularXMotion = ConfigurableJointMotion.Free;
        joint.angularYMotion = ConfigurableJointMotion.Locked;
        joint.angularZMotion = ConfigurableJointMotion.Locked;
        
        // 线性限制
        SoftJointLimit linearLimit = new SoftJointLimit();
        linearLimit.limit = 5f;
        linearLimit.bounciness = 0.1f;
        linearLimit.contactDistance = 0.1f;
        joint.linearLimit = linearLimit;
        
        // 角度限制
        SoftJointLimit angularLimit = new SoftJointLimit();
        angularLimit.limit = 45f;
        angularLimit.bounciness = 0f;
        joint.angularXLimit = angularLimit;
        
        // 弹簧驱动
        JointDrive drive = new JointDrive();
        drive.positionSpring = 1000f;    // 位置弹簧
        drive.positionDamper = 50f;      // 位置阻尼
        drive.maximumForce = Mathf.Infinity;
        joint.xDrive = drive;
    }
}
```

---

## 2D物理系统详解

### Box2D引擎特性
```csharp
// 2D物理组件结构
GameObject
├── Rigidbody2D (2D刚体)
│   ├── bodyType (物体类型)
│   ├── material (物理材质2D)
│   ├── mass (质量)
│   ├── linearDrag (线性阻尼)
│   ├── angularDrag (角阻尼)
│   ├── gravityScale (重力缩放)
│   └── constraints (约束)
├── Collider2D (2D碰撞器)
│   ├── BoxCollider2D (盒碰撞器2D)
│   ├── CircleCollider2D (圆碰撞器2D)
│   ├── PolygonCollider2D (多边形碰撞器2D)
│   ├── EdgeCollider2D (边缘碰撞器2D)
│   └── CompositeCollider2D (复合碰撞器2D)
└── Joint2D (2D关节)
    ├── DistanceJoint2D (距离关节2D)
    ├── HingeJoint2D (铰链关节2D)
    ├── SliderJoint2D (滑动关节2D)
    └── SpringJoint2D (弹簧关节2D)
```

### Rigidbody2D深度解析

#### 1. 物体类型
```csharp
public class Rigidbody2DTypes : MonoBehaviour
{
    private Rigidbody2D rb2d;
    
    void Start()
    {
        rb2d = GetComponent<Rigidbody2D>();
        
        // Dynamic：动态物体，受力和碰撞影响
        rb2d.bodyType = RigidbodyType2D.Dynamic;
        
        // Kinematic：运动学物体，不受力但影响其他物体
        rb2d.bodyType = RigidbodyType2D.Kinematic;
        
        // Static：静态物体，完全不动
        rb2d.bodyType = RigidbodyType2D.Static;
    }
    
    // 2D力的应用
    void Apply2DForces()
    {
        // 力的应用
        rb2d.AddForce(Vector2.up * 10f);
        rb2d.AddForce(Vector2.right * 5f, ForceMode2D.Impulse);
        
        // 扭矩应用
        rb2d.AddTorque(100f);
        
        // 在特定点施加力
        rb2d.AddForceAtPosition(Vector2.up * 50f, transform.position);
        
        // 直接设置速度
        rb2d.velocity = Vector2.right * 5f;
        rb2d.angularVelocity = 90f;
    }
}
```

#### 2. 物理材质2D
```csharp
public class PhysicsMaterial2DSetup : MonoBehaviour
{
    void Start()
    {
        // 创建物理材质
        PhysicsMaterial2D bouncyMaterial = new PhysicsMaterial2D("Bouncy");
        bouncyMaterial.friction = 0.1f;      // 摩擦力
        bouncyMaterial.bounciness = 0.9f;    // 弹性
        
        PhysicsMaterial2D slipperyMaterial = new PhysicsMaterial2D("Slippery");
        slipperyMaterial.friction = 0.0f;
        slipperyMaterial.bounciness = 0.0f;
        
        // 应用到碰撞器
        GetComponent<Collider2D>().material = bouncyMaterial;
        
        // 运行时修改
        ModifyMaterialProperties();
    }
    
    void ModifyMaterialProperties()
    {
        PhysicsMaterial2D material = GetComponent<Collider2D>().material;
        
        // 摩擦力计算：平均值或最小值
        // friction = sqrt(frictionA * frictionB)
        
        // 弹性计算：最大值
        // bounciness = max(bouncinessA, bouncinessB)
        
        material.friction = Mathf.Clamp01(material.friction);
        material.bounciness = Mathf.Clamp01(material.bounciness);
    }
}
```

### 2D碰撞器详解

#### 1. 高效碰撞器设计
```csharp
public class Efficient2DColliders : MonoBehaviour
{
    void Start()
    {
        // 圆形碰撞器 - 最高效
        CircleCollider2D circle = gameObject.AddComponent<CircleCollider2D>();
        circle.radius = 0.5f;
        circle.offset = Vector2.zero;
        
        // 盒碰撞器 - 次高效
        BoxCollider2D box = gameObject.AddComponent<BoxCollider2D>();
        box.size = Vector2.one;
        box.offset = Vector2.zero;
        
        // 多边形碰撞器 - 精确但较慢
        PolygonCollider2D polygon = gameObject.AddComponent<PolygonCollider2D>();
        OptimizePolygonCollider(polygon);
    }
    
    void OptimizePolygonCollider(PolygonCollider2D polygon)
    {
        // 获取当前路径点
        Vector2[] points = polygon.points;
        
        // 简化路径（移除冗余点）
        List<Vector2> simplifiedPoints = new List<Vector2>();
        
        for (int i = 0; i < points.Length; i++)
        {
            Vector2 prev = points[(i - 1 + points.Length) % points.Length];
            Vector2 current = points[i];
            Vector2 next = points[(i + 1) % points.Length];
            
            // 检查是否为共线点
            if (!IsCollinear(prev, current, next, 0.01f))
            {
                simplifiedPoints.Add(current);
            }
        }
        
        polygon.points = simplifiedPoints.ToArray();
    }
    
    bool IsCollinear(Vector2 a, Vector2 b, Vector2 c, float tolerance)
    {
        // 使用叉积判断共线
        float crossProduct = (c.y - a.y) * (b.x - a.x) - (b.y - a.y) * (c.x - a.x);
        return Mathf.Abs(crossProduct) < tolerance;
    }
}
```

#### 2. 复合碰撞器
```csharp
public class CompositeCollider2DSetup : MonoBehaviour
{
    void Start()
    {
        // 添加复合碰撞器
        CompositeCollider2D composite = gameObject.AddComponent<CompositeCollider2D>();
        composite.geometryType = CompositeCollider2D.GeometryType.Polygons;
        
        // 创建子碰撞器
        CreateChildColliders();
        
        // 设置为复合模式
        SetupCompositeMode();
    }
    
    void CreateChildColliders()
    {
        // 创建多个子物体，每个都有碰撞器
        for (int i = 0; i < 5; i++)
        {
            GameObject child = new GameObject($"ColliderPart_{i}");
            child.transform.SetParent(transform);
            child.transform.localPosition = new Vector3(i * 2f, 0, 0);
            
            BoxCollider2D childCollider = child.AddComponent<BoxCollider2D>();
            childCollider.usedByComposite = true;  // 关键：标记为复合使用
        }
    }
    
    void SetupCompositeMode()
    {
        Rigidbody2D rb = GetComponent<Rigidbody2D>();
        CompositeCollider2D composite = GetComponent<CompositeCollider2D>();
        
        // 复合碰撞器会自动合并所有子碰撞器
        // 生成单一的复杂形状，性能更好
        
        // 设置路径数量
        Debug.Log($"Generated {composite.pathCount} paths");
        
        // 获取路径点
        for (int i = 0; i < composite.pathCount; i++)
        {
            Vector2[] pathPoints = new Vector2[composite.GetPathPointCount(i)];
            composite.GetPath(i, pathPoints);
            Debug.Log($"Path {i} has {pathPoints.Length} points");
        }
    }
}
```

---

## 碰撞检测原理

### 碰撞检测算法

#### 1. 分离轴定理(SAT)
```csharp
public static class SeparatingAxisTheorem
{
    // SAT碰撞检测实现
    public static bool CheckCollision(Vector2[] shapeA, Vector2[] shapeB)
    {
        // 获取所有分离轴
        List<Vector2> axes = new List<Vector2>();
        axes.AddRange(GetAxes(shapeA));
        axes.AddRange(GetAxes(shapeB));
        
        // 在每个轴上投影并检查重叠
        foreach (Vector2 axis in axes)
        {
            Vector2 projA = ProjectShape(shapeA, axis);
            Vector2 projB = ProjectShape(shapeB, axis);
            
            // 如果在任何轴上没有重叠，则不碰撞
            if (!IsOverlapping(projA, projB))
            {
                return false;
            }
        }
        
        return true; // 所有轴都重叠，发生碰撞
    }
    
    static Vector2[] GetAxes(Vector2[] shape)
    {
        Vector2[] axes = new Vector2[shape.Length];
        
        for (int i = 0; i < shape.Length; i++)
        {
            Vector2 edge = shape[(i + 1) % shape.Length] - shape[i];
            axes[i] = new Vector2(-edge.y, edge.x).normalized; // 垂直向量
        }
        
        return axes;
    }
    
    static Vector2 ProjectShape(Vector2[] shape, Vector2 axis)
    {
        float min = Vector2.Dot(shape[0], axis);
        float max = min;
        
        for (int i = 1; i < shape.Length; i++)
        {
            float projection = Vector2.Dot(shape[i], axis);
            min = Mathf.Min(min, projection);
            max = Mathf.Max(max, projection);
        }
        
        return new Vector2(min, max);
    }
    
    static bool IsOverlapping(Vector2 projA, Vector2 projB)
    {
        return projA.x <= projB.y && projB.x <= projA.y;
    }
}
```

#### 2. GJK算法
```csharp
public static class GJKAlgorithm
{
    // Gilbert-Johnson-Keerthi距离算法
    public static bool CheckCollision(IConvexShape shapeA, IConvexShape shapeB)
    {
        Vector2 direction = Vector2.right; // 初始搜索方向
        Vector2 support = GetSupport(shapeA, shapeB, direction);
        
        List<Vector2> simplex = new List<Vector2> { support };
        direction = -support;
        
        while (true)
        {
            support = GetSupport(shapeA, shapeB, direction);
            
            if (Vector2.Dot(support, direction) <= 0)
            {
                return false; // 没有跨越原点
            }
            
            simplex.Add(support);
            
            if (ContainsOrigin(simplex, ref direction))
            {
                return true; // 包含原点，发生碰撞
            }
        }
    }
    
    static Vector2 GetSupport(IConvexShape shapeA, IConvexShape shapeB, Vector2 direction)
    {
        return shapeA.GetFarthestPoint(direction) - shapeB.GetFarthestPoint(-direction);
    }
    
    static bool ContainsOrigin(List<Vector2> simplex, ref Vector2 direction)
    {
        Vector2 a = simplex[simplex.Count - 1];
        Vector2 ao = -a;
        
        if (simplex.Count == 3)
        {
            // 三角形单纯形
            Vector2 b = simplex[1];
            Vector2 c = simplex[0];
            
            Vector2 ab = b - a;
            Vector2 ac = c - a;
            
            Vector2 abPerp = TripleProduct(ac, ab, ab);
            Vector2 acPerp = TripleProduct(ab, ac, ac);
            
            if (Vector2.Dot(abPerp, ao) > 0)
            {
                simplex.RemoveAt(0);
                direction = abPerp;
            }
            else if (Vector2.Dot(acPerp, ao) > 0)
            {
                simplex.RemoveAt(1);
                direction = acPerp;
            }
            else
            {
                return true; // 包含原点
            }
        }
        else
        {
            // 线段单纯形
            Vector2 b = simplex[0];
            Vector2 ab = b - a;
            Vector2 abPerp = TripleProduct(ab, ao, ab);
            direction = abPerp;
        }
        
        return false;
    }
    
    static Vector2 TripleProduct(Vector2 a, Vector2 b, Vector2 c)
    {
        float ac = a.x * c.x + a.y * c.y;
        float bc = b.x * c.x + b.y * c.y;
        return new Vector2(b.x * ac - a.x * bc, b.y * ac - a.y * bc);
    }
}
```

### 碰撞事件系统

#### 1. 碰撞回调机制
```csharp
public class CollisionEventHandler : MonoBehaviour
{
    // 3D碰撞事件
    void OnTriggerEnter(Collider other)
    {
        Debug.Log($"Trigger Enter: {other.name}");
        HandleTriggerEnter(other);
    }
    
    void OnTriggerStay(Collider other)
    {
        // 每帧调用，注意性能
        HandleTriggerStay(other);
    }
    
    void OnTriggerExit(Collider other)
    {
        Debug.Log($"Trigger Exit: {other.name}");
        HandleTriggerExit(other);
    }
    
    void OnCollisionEnter(Collision collision)
    {
        Debug.Log($"Collision Enter: {collision.gameObject.name}");
        
        // 碰撞信息分析
        ContactPoint contact = collision.contacts[0];
        Vector3 hitPoint = contact.point;
        Vector3 hitNormal = contact.normal;
        float impact = collision.relativeVelocity.magnitude;
        
        HandleCollision(collision, hitPoint, hitNormal, impact);
    }
    
    // 2D碰撞事件
    void OnTriggerEnter2D(Collider2D other)
    {
        Debug.Log($"2D Trigger Enter: {other.name}");
    }
    
    void OnCollisionEnter2D(Collision2D collision)
    {
        Debug.Log($"2D Collision Enter: {collision.gameObject.name}");
        
        // 2D碰撞信息
        ContactPoint2D contact = collision.contacts[0];
        Vector2 hitPoint = contact.point;
        Vector2 hitNormal = contact.normal;
        float separation = contact.separation;
        
        Handle2DCollision(collision, hitPoint, hitNormal);
    }
}
```

#### 2. 碰撞过滤系统
```csharp
public class CollisionFiltering : MonoBehaviour
{
    void Start()
    {
        SetupLayerMatrix();
        SetupIgnoreCollisions();
    }
    
    void SetupLayerMatrix()
    {
        // 设置层级碰撞矩阵
        int playerLayer = LayerMask.NameToLayer("Player");
        int enemyLayer = LayerMask.NameToLayer("Enemy");
        int pickupLayer = LayerMask.NameToLayer("Pickup");
        
        // 玩家与敌人碰撞
        Physics.IgnoreLayerCollision(playerLayer, enemyLayer, false);
        
        // 拾取物不与拾取物碰撞
        Physics.IgnoreLayerCollision(pickupLayer, pickupLayer, true);
        
        // 2D版本
        Physics2D.IgnoreLayerCollision(playerLayer, enemyLayer, false);
    }
    
    void SetupIgnoreCollisions()
    {
        // 忽略特定碰撞器组合
        Collider playerCollider = GameObject.FindWithTag("Player").GetComponent<Collider>();
        Collider[] pickups = FindObjectsOfType<Collider>();
        
        foreach (Collider pickup in pickups)
        {
            if (pickup.CompareTag("Pickup"))
            {
                Physics.IgnoreCollision(playerCollider, pickup);
            }
        }
    }
}
```

---

## 物理优化策略

### 1. 性能优化
```csharp
public class PhysicsOptimization : MonoBehaviour
{
    [Header("物理设置")]
    public int physicsIterations = 6;
    public int physicsVelocityIterations = 1;
    
    void Start()
    {
        OptimizePhysicsSettings();
        SetupLODSystem();
    }
    
    void OptimizePhysicsSettings()
    {
        // 调整物理求解器迭代次数
        Physics.defaultSolverIterations = physicsIterations;
        Physics.defaultSolverVelocityIterations = physicsVelocityIterations;
        
        // 2D物理设置
        Physics2D.velocityIterations = 8;
        Physics2D.positionIterations = 3;
        
        // 自动同步Transform
        Physics.autoSyncTransforms = false; // 手动控制可提高性能
        
        // 碰撞器烹饪设置
        Physics.cookingOptions = MeshColliderCookingOptions.CookForFasterSimulation;
    }
    
    void SetupLODSystem()
    {
        // 基于距离的物理LOD
        StartCoroutine(PhysicsLODUpdate());
    }
    
    IEnumerator PhysicsLODUpdate()
    {
        while (true)
        {
            Camera mainCamera = Camera.main;
            Rigidbody[] allRigidbodies = FindObjectsOfType<Rigidbody>();
            
            foreach (Rigidbody rb in allRigidbodies)
            {
                float distance = Vector3.Distance(rb.transform.position, mainCamera.transform.position);
                
                if (distance > 50f)
                {
                    // 远距离：睡眠物理
                    rb.Sleep();
                }
                else if (distance > 20f)
                {
                    // 中距离：降低精度
                    rb.solverIterations = 2;
                    rb.solverVelocityIterations = 1;
                }
                else
                {
                    // 近距离：正常精度
                    rb.solverIterations = 6;
                    rb.solverVelocityIterations = 1;
                    
                    if (rb.IsSleeping())
                        rb.WakeUp();
                }
            }
            
            yield return new WaitForSeconds(0.5f); // 每0.5秒更新一次LOD
        }
    }
}
```

### 2. 内存优化
```csharp
public class PhysicsMemoryOptimization : MonoBehaviour
{
    private ObjectPool<Rigidbody> rigidbodyPool;
    private Dictionary<Mesh, Mesh> simplifiedMeshCache;
    
    void Start()
    {
        InitializePools();
        OptimizeMeshColliders();
    }
    
    void InitializePools()
    {
        // 物理对象池
        rigidbodyPool = new ObjectPool<Rigidbody>(
            createFunc: () => CreatePhysicsObject(),
            actionOnGet: (rb) => rb.gameObject.SetActive(true),
            actionOnRelease: (rb) => rb.gameObject.SetActive(false),
            actionOnDestroy: (rb) => Destroy(rb.gameObject),
            collectionCheck: false,
            defaultCapacity: 100,
            maxSize: 500
        );
    }
    
    Rigidbody CreatePhysicsObject()
    {
        GameObject go = new GameObject("PooledPhysicsObject");
        Rigidbody rb = go.AddComponent<Rigidbody>();
        go.AddComponent<BoxCollider>();
        return rb;
    }
    
    void OptimizeMeshColliders()
    {
        simplifiedMeshCache = new Dictionary<Mesh, Mesh>();
        
        MeshCollider[] allMeshColliders = FindObjectsOfType<MeshCollider>();
        
        foreach (MeshCollider meshCollider in allMeshColliders)
        {
            Mesh originalMesh = meshCollider.sharedMesh;
            
            if (!simplifiedMeshCache.ContainsKey(originalMesh))
            {
                // 创建简化的碰撞网格
                Mesh simplifiedMesh = SimplifyMesh(originalMesh);
                simplifiedMeshCache[originalMesh] = simplifiedMesh;
            }
            
            meshCollider.sharedMesh = simplifiedMeshCache[originalMesh];
        }
    }
    
    Mesh SimplifyMesh(Mesh originalMesh)
    {
        // 网格简化算法
        Vector3[] originalVertices = originalMesh.vertices;
        int[] originalTriangles = originalMesh.triangles;
        
        // 使用更简单的几何形状
        if (originalVertices.Length > 1000)
        {
            // 如果顶点太多，使用包围盒代替
            Bounds bounds = originalMesh.bounds;
            return CreateBoxMesh(bounds.size);
        }
        
        // 否则进行顶点合并
        return MergeVertices(originalMesh, 0.01f);
    }
}
```

---

## 常见面试问题

### 1. **Q: Unity中3D物理和2D物理的区别？**
```
A: 核心区别：
1. 引擎基础：
   - 3D：基于PhysX 3.4，支持复杂3D计算
   - 2D：基于Box2D，专为2D优化

2. 组件差异：
   - 3D：Rigidbody、Collider、Joint
   - 2D：Rigidbody2D、Collider2D、Joint2D

3. 性能特性：
   - 2D物理更轻量，适合移动平台
   - 3D物理功能更丰富，支持复杂模拟

4. 坐标系统：
   - 2D：Z轴固定，只在XY平面计算
   - 3D：完整的三维空间计算
```

### 2. **Q: Rigidbody的isKinematic属性的作用？**
```
A: Kinematic模式特点：
1. 运动特性：
   - 不受力和重力影响
   - 可以通过Transform直接移动
   - 影响其他Dynamic物体

2. 碰撞行为：
   - 可以触发Trigger事件
   - 可以与Dynamic物体产生碰撞
   - 不会被其他物体推动

3. 使用场景：
   - 平台移动（电梯、传送带）
   - 角色控制器
   - 动画驱动的物体

4. 性能优势：
   - 不参与物理求解，性能更好
   - 适合可预测的运动模式
```

### 3. **Q: 物理材质的摩擦力和弹性如何计算？**
```
A: 材质混合公式：
1. 摩擦力计算：
   // 平均值方式
   friction = (frictionA + frictionB) / 2
   
   // 几何平均（Unity默认）
   friction = sqrt(frictionA * frictionB)
   
   // 最小值方式
   friction = min(frictionA, frictionB)

2. 弹性计算：
   // 最大值方式（Unity默认）
   bounciness = max(bouncinessA, bouncinessB)
   
   // 平均值方式
   bounciness = (bouncinessA + bouncinessB) / 2

3. 组合模式设置：
   PhysicMaterial.frictionCombine = PhysicMaterialCombine.Average;
   PhysicMaterial.bounceCombine = PhysicMaterialCombine.Maximum;
```

### 4. **Q: FixedUpdate和Update在物理系统中的区别？**
```
A: 时间步长差异：
1. FixedUpdate：
   - 固定时间间隔调用（默认50Hz）
   - 与物理模拟同步
   - 适合物理计算和输入处理

2. Update：
   - 每帧调用，频率不固定
   - 与渲染帧率相关
   - 适合UI更新和视觉效果

3. 物理插值：
   // 在FixedUpdate中修改物理
   void FixedUpdate()
   {
       rb.AddForce(inputDirection * force);
   }
   
   // 在Update中插值显示
   void Update()
   {
       // 视觉位置插值
       visualTransform.position = Vector3.Lerp(
           previousPosition, 
           rigidbody.position, 
           Time.time / Time.fixedTime
       );
   }
```

### 5. **Q: 碰撞检测的性能优化方法？**
```
A: 优化策略：
1. 层级管理：
   - 合理设置Layer Matrix
   - 减少不必要的碰撞检测

2. 碰撞器优化：
   - 优先使用原始碰撞器（Box、Sphere）
   - 避免复杂的Mesh Collider
   - 使用Compound Collider组合

3. 空间分割：
   - 实现四叉树/八叉树
   - 只检测附近的物体

4. 时间分片：
   - 将碰撞检测分散到多帧
   - 使用协程进行异步检测

代码示例：
public class SpatialHashGrid
{
    private Dictionary<int, List<Collider>> grid;
    private float cellSize;
    
    public List<Collider> Query(Vector3 position, float radius)
    {
        List<Collider> results = new List<Collider>();
        int minX = Mathf.FloorToInt((position.x - radius) / cellSize);
        int maxX = Mathf.FloorToInt((position.x + radius) / cellSize);
        // ... 查询网格并返回候选对象
        return results;
    }
}
```

---

*这份文档深入讲解了Unity物理系统的各个方面，从基础原理到高级优化，适合技术面试的深度准备。*