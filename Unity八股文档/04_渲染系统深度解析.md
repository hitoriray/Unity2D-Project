# Unity渲染系统深度解析

## 目录
1. [渲染架构概述](#渲染架构概述)
2. [渲染管线详解](#渲染管线详解)
3. [Shader系统原理](#shader系统原理)
4. [光照系统详解](#光照系统详解)
5. [渲染优化策略](#渲染优化策略)
6. [常见面试问题](#常见面试问题)

---

## 渲染架构概述

### Unity渲染系统发展
```
Built-in Render Pipeline (传统管线)
├── 固定功能管线
├── 有限的自定义能力
└── 适合简单项目

↓

Scriptable Render Pipeline (SRP)
├── High Definition Render Pipeline (HDRP)
│   ├── 高端PC/主机平台
│   ├── 物理基础渲染
│   └── 高质量视觉效果
├── Universal Render Pipeline (URP)
│   ├── 跨平台优化
│   ├── 移动端友好
│   └── 高性能渲染
└── Custom Render Pipeline
    ├── 完全自定义
    ├── 专项优化
    └── 特殊需求
```

### 渲染系统核心组件
```csharp
// 渲染系统架构
RenderPipelineAsset
├── RenderPipeline (渲染管线实例)
│   ├── CameraRenderer (相机渲染器)
│   ├── LightRenderer (光照渲染器)
│   └── PostProcessRenderer (后处理渲染器)
├── Camera (相机)
│   ├── CullingMask (剔除遮罩)
│   ├── RenderingPath (渲染路径)
│   └── CameraType (相机类型)
├── Renderer (渲染器)
│   ├── MeshRenderer (网格渲染器)
│   ├── SkinnedMeshRenderer (蒙皮网格渲染器)
│   ├── ParticleSystemRenderer (粒子系统渲染器)
│   └── SpriteRenderer (精灵渲染器)
└── Material/Shader (材质/着色器)
    ├── Vertex Shader (顶点着色器)
    ├── Fragment Shader (片段着色器)
    └── Compute Shader (计算着色器)
```

---

## 渲染管线详解

### Built-in渲染管线

#### 1. 渲染流程
```csharp
public class BuiltinRenderPipeline
{
    // Built-in管线的渲染流程（简化版）
    void RenderFrame()
    {
        // 1. 应用层提交
        ApplicationSubmission();
        
        // 2. 剔除
        PerformCulling();
        
        // 3. 深度预通道
        if (camera.depthTextureMode != DepthTextureMode.None)
        {
            RenderDepthPrepass();
        }
        
        // 4. 阴影映射
        RenderShadowMaps();
        
        // 5. 不透明几何体
        RenderOpaqueGeometry();
        
        // 6. 天空盒
        RenderSkybox();
        
        // 7. 透明几何体
        RenderTransparentGeometry();
        
        // 8. 后处理
        RenderPostProcessing();
    }
    
    void PerformCulling()
    {
        // 视锥剔除
        FrustumCulling();
        
        // 遮挡剔除
        OcclusionCulling();
        
        // 距离剔除
        DistanceCulling();
        
        // 层级剔除
        LayerCulling();
    }
    
    void FrustumCulling()
    {
        Camera camera = Camera.current;
        Plane[] frustumPlanes = GeometryUtility.CalculateFrustumPlanes(camera);
        
        Renderer[] allRenderers = FindObjectsOfType<Renderer>();
        
        foreach (Renderer renderer in allRenderers)
        {
            Bounds bounds = renderer.bounds;
            
            // 检查包围盒是否在视锥内
            if (GeometryUtility.TestPlanesAABB(frustumPlanes, bounds))
            {
                // 在视锥内，提交渲染
                SubmitForRendering(renderer);
            }
        }
    }
}
```

#### 2. 光照计算模型
```csharp
public class BuiltinLighting
{
    // Phong光照模型
    Vector3 CalculatePhongLighting(Vector3 lightDir, Vector3 normal, Vector3 viewDir, 
                                  Color lightColor, Material material)
    {
        // 环境光
        Vector3 ambient = RenderSettings.ambientLight * material.color;
        
        // 漫反射
        float NdotL = Mathf.Max(0, Vector3.Dot(normal, lightDir));
        Vector3 diffuse = lightColor * material.color * NdotL;
        
        // 镜面反射
        Vector3 reflectDir = Vector3.Reflect(-lightDir, normal);
        float RdotV = Mathf.Max(0, Vector3.Dot(reflectDir, viewDir));
        float specular = Mathf.Pow(RdotV, material.shininess);
        Vector3 specularColor = lightColor * material.specularColor * specular;
        
        return ambient + diffuse + specularColor;
    }
    
    // Blinn-Phong光照模型（性能更好）
    Vector3 CalculateBlinnPhongLighting(Vector3 lightDir, Vector3 normal, Vector3 viewDir,
                                       Color lightColor, Material material)
    {
        Vector3 ambient = RenderSettings.ambientLight * material.color;
        
        float NdotL = Mathf.Max(0, Vector3.Dot(normal, lightDir));
        Vector3 diffuse = lightColor * material.color * NdotL;
        
        // 半角向量
        Vector3 halfwayDir = (lightDir + viewDir).normalized;
        float NdotH = Mathf.Max(0, Vector3.Dot(normal, halfwayDir));
        float specular = Mathf.Pow(NdotH, material.shininess);
        Vector3 specularColor = lightColor * material.specularColor * specular;
        
        return ambient + diffuse + specularColor;
    }
}
```

### URP渲染管线

#### 1. URP架构实现
```csharp
[CreateAssetMenu(menuName = "Rendering/Custom URP Pipeline Asset")]
public class CustomURPAsset : RenderPipelineAsset
{
    [SerializeField] private bool useSRPBatcher = true;
    [SerializeField] private bool supportHDR = false;
    [SerializeField] private int msaaSampleCount = 1;
    [SerializeField] private RenderScale renderScale = RenderScale.Unity;
    
    protected override RenderPipeline CreatePipeline()
    {
        return new CustomURPRenderPipeline(this);
    }
}

public class CustomURPRenderPipeline : RenderPipeline
{
    private CustomURPAsset pipelineAsset;
    private CustomCameraRenderer cameraRenderer = new CustomCameraRenderer();
    
    public CustomURPRenderPipeline(CustomURPAsset asset)
    {
        pipelineAsset = asset;
        
        // 设置全局渲染设置
        GraphicsSettings.useScriptableRenderPipelineBatching = asset.useSRPBatcher;
        GraphicsSettings.lightsUseLinearIntensity = true;
    }
    
    protected override void Render(ScriptableRenderContext context, Camera[] cameras)
    {
        // 渲染所有相机
        foreach (Camera camera in cameras)
        {
            cameraRenderer.Render(context, camera, pipelineAsset);
        }
    }
}

public class CustomCameraRenderer
{
    private ScriptableRenderContext context;
    private Camera camera;
    private CustomURPAsset pipelineAsset;
    
    // CommandBuffer用于GPU命令记录
    private CommandBuffer commandBuffer = new CommandBuffer { name = "Camera Renderer" };
    
    // 渲染队列标识
    private static ShaderTagId unlitShaderTagId = new ShaderTagId("SRPDefaultUnlit");
    private static ShaderTagId litShaderTagId = new ShaderTagId("UniversalForward");
    
    public void Render(ScriptableRenderContext context, Camera camera, CustomURPAsset pipelineAsset)
    {
        this.context = context;
        this.camera = camera;
        this.pipelineAsset = pipelineAsset;
        
        // 1. 设置渲染目标
        SetupRenderTarget();
        
        // 2. 剔除
        if (!Cull())
            return;
        
        // 3. 设置光照
        SetupLights();
        
        // 4. 渲染不透明物体
        DrawOpaqueGeometry();
        
        // 5. 渲染天空盒
        DrawSkybox();
        
        // 6. 渲染透明物体
        DrawTransparentGeometry();
        
        // 7. 提交命令
        Submit();
    }
    
    void SetupRenderTarget()
    {
        // 清除渲染目标
        commandBuffer.ClearRenderTarget(true, true, camera.backgroundColor);
        
        // 设置相机矩阵
        commandBuffer.SetViewProjectionMatrices(camera.worldToCameraMatrix, camera.projectionMatrix);
        
        ExecuteCommandBuffer();
    }
    
    bool Cull()
    {
        // 获取剔除参数
        ScriptableCullingParameters cullingParameters;
        if (!camera.TryGetCullingParameters(out cullingParameters))
            return false;
        
        // 执行剔除
        cullingResults = context.Cull(ref cullingParameters);
        return true;
    }
    
    CullingResults cullingResults;
    
    void SetupLights()
    {
        // 设置光照数据
        NativeArray<VisibleLight> visibleLights = cullingResults.visibleLights;
        
        // 提取主方向光
        for (int i = 0; i < visibleLights.Length; i++)
        {
            VisibleLight light = visibleLights[i];
            
            if (light.lightType == LightType.Directional)
            {
                Vector4 lightDirection = -light.localToWorldMatrix.GetColumn(2);
                commandBuffer.SetGlobalVector("_MainLightDirection", lightDirection);
                commandBuffer.SetGlobalColor("_MainLightColor", light.finalColor);
                break;
            }
        }
        
        ExecuteCommandBuffer();
    }
    
    void DrawOpaqueGeometry()
    {
        // 排序设置
        var sortingSettings = new SortingSettings(camera)
        {
            criteria = SortingCriteria.CommonOpaque
        };
        
        // 绘制设置
        var drawingSettings = new DrawingSettings(unlitShaderTagId, sortingSettings);
        drawingSettings.SetShaderPassName(1, litShaderTagId);
        
        // 过滤设置
        var filteringSettings = new FilteringSettings(RenderQueueRange.opaque);
        
        // 执行绘制
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);
    }
    
    void DrawSkybox()
    {
        context.DrawSkybox(camera);
    }
    
    void DrawTransparentGeometry()
    {
        var sortingSettings = new SortingSettings(camera)
        {
            criteria = SortingCriteria.CommonTransparent
        };
        
        var drawingSettings = new DrawingSettings(unlitShaderTagId, sortingSettings);
        drawingSettings.SetShaderPassName(1, litShaderTagId);
        
        var filteringSettings = new FilteringSettings(RenderQueueRange.transparent);
        
        context.DrawRenderers(cullingResults, ref drawingSettings, ref filteringSettings);
    }
    
    void ExecuteCommandBuffer()
    {
        context.ExecuteCommandBuffer(commandBuffer);
        commandBuffer.Clear();
    }
    
    void Submit()
    {
        context.Submit();
    }
}
```

#### 2. SRP Batcher优化
```csharp
public class SRPBatcherOptimization
{
    // SRP Batcher兼容的Shader结构
    /*
    HLSL示例：
    CBUFFER_START(UnityPerMaterial)
        float4 _BaseColor;
        float _Metallic;
        float _Smoothness;
    CBUFFER_END
    
    CBUFFER_START(UnityPerDraw)
        float4x4 unity_ObjectToWorld;
        float4x4 unity_WorldToObject;
        float4 unity_LODFade;
        real4 unity_WorldTransformParams;
    CBUFFER_END
    */
    
    void OptimizeForSRPBatcher()
    {
        // 1. 确保材质属性在正确的CBUFFER中
        ValidateMaterialCBuffers();
        
        // 2. 避免材质属性的运行时修改
        AvoidRuntimeMaterialChanges();
        
        // 3. 使用MaterialPropertyBlock代替材质实例
        UseMaterialPropertyBlocks();
    }
    
    void ValidateMaterialCBuffers()
    {
        Material[] materials = Resources.FindObjectsOfTypeAll<Material>();
        
        foreach (Material material in materials)
        {
            Shader shader = material.shader;
            
            // 检查Shader是否兼容SRP Batcher
            if (shader.HasProperty("_BaseColor"))
            {
                // 确认属性在UnityPerMaterial中定义
                Debug.Log($"Material {material.name} is SRP Batcher compatible");
            }
        }
    }
    
    void AvoidRuntimeMaterialChanges()
    {
        // 错误做法：运行时修改材质属性
        // material.SetFloat("_Metallic", 0.5f); // 这会破坏SRP Batcher
        
        // 正确做法：使用MaterialPropertyBlock
        MaterialPropertyBlock mpb = new MaterialPropertyBlock();
        mpb.SetFloat("_Metallic", 0.5f);
        
        Renderer renderer = GetComponent<Renderer>();
        renderer.SetPropertyBlock(mpb);
    }
    
    void UseMaterialPropertyBlocks()
    {
        // 高效的per-object属性设置
        MaterialPropertyBlock propertyBlock = new MaterialPropertyBlock();
        
        // 批量设置属性
        propertyBlock.SetFloat("_Metallic", Random.Range(0f, 1f));
        propertyBlock.SetColor("_BaseColor", Random.ColorHSV());
        propertyBlock.SetVector("_CustomData", new Vector4(1, 2, 3, 4));
        
        // 应用到渲染器
        GetComponent<Renderer>().SetPropertyBlock(propertyBlock);
    }
}
```

---

## Shader系统原理

### Shader基础架构

#### 1. Shader结构解析
```hlsl
// Unity Shader基本结构
Shader "Custom/BasicShader"
{
    Properties
    {
        // 着色器属性
        _MainTex ("Texture", 2D) = "white" {}
        _Color ("Color", Color) = (1,1,1,1)
        _Metallic ("Metallic", Range(0,1)) = 0.0
        _Smoothness ("Smoothness", Range(0,1)) = 0.5
    }
    
    SubShader
    {
        Tags 
        { 
            "RenderType"="Opaque" 
            "RenderPipeline"="UniversalPipeline"
        }
        
        LOD 200
        
        Pass
        {
            Name "ForwardLit"
            Tags {"LightMode"="UniversalForward"}
            
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            
            // 顶点输入结构
            struct Attributes
            {
                float4 positionOS : POSITION;
                float3 normalOS : NORMAL;
                float2 uv : TEXCOORD0;
            };
            
            // 顶点输出/片段输入结构
            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float3 positionWS : TEXCOORD0;
                float3 normalWS : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            // 材质属性
            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            
            CBUFFER_START(UnityPerMaterial)
                float4 _MainTex_ST;
                float4 _Color;
                float _Metallic;
                float _Smoothness;
            CBUFFER_END
            
            // 顶点着色器
            Varyings vert(Attributes input)
            {
                Varyings output = (Varyings)0;
                
                // 坐标空间转换
                output.positionWS = TransformObjectToWorld(input.positionOS.xyz);
                output.positionCS = TransformWorldToHClip(output.positionWS);
                output.normalWS = TransformObjectToWorldNormal(input.normalOS);
                output.uv = TRANSFORM_TEX(input.uv, _MainTex);
                
                return output;
            }
            
            // 片段着色器
            float4 frag(Varyings input) : SV_Target
            {
                // 纹理采样
                float4 texColor = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv);
                float4 baseColor = texColor * _Color;
                
                // 法线处理
                float3 normalWS = normalize(input.normalWS);
                
                // 获取主光源
                Light mainLight = GetMainLight();
                
                // 计算光照
                float3 lightColor = mainLight.color;
                float3 lightDir = normalize(mainLight.direction);
                
                // Lambert漫反射
                float NdotL = saturate(dot(normalWS, lightDir));
                float3 diffuse = baseColor.rgb * lightColor * NdotL;
                
                // 环境光
                float3 ambient = baseColor.rgb * 0.1;
                
                float3 finalColor = diffuse + ambient;
                
                return float4(finalColor, baseColor.a);
            }
            
            ENDHLSL
        }
    }
    
    FallBack "Hidden/Universal Render Pipeline/FallbackError"
}
```

#### 2. PBR着色器实现
```hlsl
// 物理基础渲染(PBR)着色器
Shader "Custom/PBRShader"
{
    Properties
    {
        _BaseMap("Base Map", 2D) = "white" {}
        _BaseColor("Base Color", Color) = (1, 1, 1, 1)
        _MetallicGlossMap("Metallic", 2D) = "white" {}
        _Metallic("Metallic", Range(0.0, 1.0)) = 0.0
        _Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5
        _BumpMap("Normal Map", 2D) = "bump" {}
        _BumpScale("Normal Scale", Float) = 1.0
        _OcclusionMap("Occlusion", 2D) = "white" {}
        _OcclusionStrength("Occlusion Strength", Range(0.0, 1.0)) = 1.0
    }
    
    SubShader
    {
        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            
            struct Attributes
            {
                float4 positionOS : POSITION;
                float3 normalOS : NORMAL;
                float4 tangentOS : TANGENT;
                float2 uv : TEXCOORD0;
            };
            
            struct Varyings
            {
                float4 positionCS : SV_POSITION;
                float3 positionWS : TEXCOORD0;
                float3 normalWS : TEXCOORD1;
                float3 tangentWS : TEXCOORD2;
                float3 bitangentWS : TEXCOORD3;
                float2 uv : TEXCOORD4;
            };
            
            TEXTURE2D(_BaseMap);
            TEXTURE2D(_MetallicGlossMap);
            TEXTURE2D(_BumpMap);
            TEXTURE2D(_OcclusionMap);
            SAMPLER(sampler_BaseMap);
            
            CBUFFER_START(UnityPerMaterial)
                float4 _BaseMap_ST;
                float4 _BaseColor;
                float _Metallic;
                float _Smoothness;
                float _BumpScale;
                float _OcclusionStrength;
            CBUFFER_END
            
            Varyings vert(Attributes input)
            {
                Varyings output = (Varyings)0;
                
                output.positionWS = TransformObjectToWorld(input.positionOS.xyz);
                output.positionCS = TransformWorldToHClip(output.positionWS);
                
                // 计算TBN矩阵
                output.normalWS = TransformObjectToWorldNormal(input.normalOS);
                output.tangentWS = TransformObjectToWorldDir(input.tangentOS.xyz);
                output.bitangentWS = cross(output.normalWS, output.tangentWS) * input.tangentOS.w;
                
                output.uv = TRANSFORM_TEX(input.uv, _BaseMap);
                
                return output;
            }
            
            // BRDF计算函数
            float DistributionGGX(float3 N, float3 H, float roughness)
            {
                float a = roughness * roughness;
                float a2 = a * a;
                float NdotH = max(dot(N, H), 0.0);
                float NdotH2 = NdotH * NdotH;
                
                float num = a2;
                float denom = (NdotH2 * (a2 - 1.0) + 1.0);
                denom = PI * denom * denom;
                
                return num / denom;
            }
            
            float GeometrySchlickGGX(float NdotV, float roughness)
            {
                float r = (roughness + 1.0);
                float k = (r * r) / 8.0;
                
                float num = NdotV;
                float denom = NdotV * (1.0 - k) + k;
                
                return num / denom;
            }
            
            float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
            {
                float NdotV = max(dot(N, V), 0.0);
                float NdotL = max(dot(N, L), 0.0);
                float ggx2 = GeometrySchlickGGX(NdotV, roughness);
                float ggx1 = GeometrySchlickGGX(NdotL, roughness);
                
                return ggx1 * ggx2;
            }
            
            float3 FresnelSchlick(float cosTheta, float3 F0)
            {
                return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
            }
            
            float4 frag(Varyings input) : SV_Target
            {
                // 采样纹理
                float4 albedo = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, input.uv) * _BaseColor;
                float4 metallicGloss = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_BaseMap, input.uv);
                float3 normalTS = UnpackNormalScale(SAMPLE_TEXTURE2D(_BumpMap, sampler_BaseMap, input.uv), _BumpScale);
                float occlusion = SAMPLE_TEXTURE2D(_OcclusionMap, sampler_BaseMap, input.uv).g;
                
                // 计算法线
                float3x3 TBN = float3x3(input.tangentWS, input.bitangentWS, input.normalWS);
                float3 N = normalize(mul(normalTS, TBN));
                
                // 计算向量
                float3 V = normalize(GetCameraPositionWS() - input.positionWS);
                
                // 材质属性
                float metallic = metallicGloss.r * _Metallic;
                float roughness = 1.0 - (metallicGloss.a * _Smoothness);
                float3 F0 = lerp(float3(0.04, 0.04, 0.04), albedo.rgb, metallic);
                
                // 获取光源
                Light mainLight = GetMainLight();
                float3 L = normalize(mainLight.direction);
                float3 H = normalize(V + L);
                
                // Cook-Torrance BRDF
                float NDF = DistributionGGX(N, H, roughness);
                float G = GeometrySmith(N, V, L, roughness);
                float3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);
                
                float3 kS = F;
                float3 kD = float3(1.0, 1.0, 1.0) - kS;
                kD *= 1.0 - metallic;
                
                float3 numerator = NDF * G * F;
                float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
                float3 specular = numerator / denominator;
                
                float NdotL = max(dot(N, L), 0.0);
                float3 Lo = (kD * albedo.rgb / PI + specular) * mainLight.color * NdotL;
                
                // 环境光
                float3 ambient = float3(0.03, 0.03, 0.03) * albedo.rgb * occlusion;
                float3 color = ambient + Lo;
                
                // HDR色调映射
                color = color / (color + float3(1.0, 1.0, 1.0));
                color = pow(color, float3(1.0/2.2, 1.0/2.2, 1.0/2.2));
                
                return float4(color, albedo.a);
            }
            
            ENDHLSL
        }
    }
}
```

### Compute Shader

#### 1. 基础Compute Shader
```hlsl
// ComputeShader示例：粒子系统
#pragma kernel UpdateParticles

struct Particle
{
    float3 position;
    float3 velocity;
    float life;
    float startLife;
};

RWStructuredBuffer<Particle> particleBuffer;
float deltaTime;
float3 gravity;

[numthreads(64, 1, 1)]
void UpdateParticles(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    if (index >= particleBuffer.Length)
        return;
    
    Particle p = particleBuffer[index];
    
    // 更新生命周期
    p.life -= deltaTime;
    
    if (p.life > 0)
    {
        // 更新速度（重力）
        p.velocity += gravity * deltaTime;
        
        // 更新位置
        p.position += p.velocity * deltaTime;
        
        particleBuffer[index] = p;
    }
    else
    {
        // 重置粒子
        p.life = p.startLife;
        p.position = float3(0, 0, 0);
        p.velocity = float3(
            (frac(sin(index * 12.9898) * 43758.5453) - 0.5) * 2.0,
            (frac(sin(index * 78.233) * 43758.5453)) * 5.0,
            (frac(sin(index * 35.456) * 43758.5453) - 0.5) * 2.0
        );
        
        particleBuffer[index] = p;
    }
}
```

#### 2. Compute Shader C#控制
```csharp
public class ComputeShaderController : MonoBehaviour
{
    public ComputeShader particleComputeShader;
    public Material particleMaterial;
    public int particleCount = 10000;
    
    private ComputeBuffer particleBuffer;
    private Particle[] particles;
    private int updateKernel;
    
    struct Particle
    {
        public Vector3 position;
        public Vector3 velocity;
        public float life;
        public float startLife;
    }
    
    void Start()
    {
        InitializeParticles();
        SetupComputeShader();
    }
    
    void InitializeParticles()
    {
        particles = new Particle[particleCount];
        
        for (int i = 0; i < particleCount; i++)
        {
            particles[i] = new Particle
            {
                position = Vector3.zero,
                velocity = new Vector3(
                    UnityEngine.Random.Range(-1f, 1f),
                    UnityEngine.Random.Range(0f, 5f),
                    UnityEngine.Random.Range(-1f, 1f)
                ),
                life = UnityEngine.Random.Range(1f, 5f),
                startLife = UnityEngine.Random.Range(1f, 5f)
            };
        }
    }
    
    void SetupComputeShader()
    {
        // 创建ComputeBuffer
        int stride = sizeof(float) * 8; // 3+3+1+1 floats
        particleBuffer = new ComputeBuffer(particleCount, stride);
        particleBuffer.SetData(particles);
        
        // 获取kernel
        updateKernel = particleComputeShader.FindKernel("UpdateParticles");
        
        // 设置buffer
        particleComputeShader.SetBuffer(updateKernel, "particleBuffer", particleBuffer);
        
        // 设置材质buffer（用于渲染）
        particleMaterial.SetBuffer("particleBuffer", particleBuffer);
    }
    
    void Update()
    {
        // 设置参数
        particleComputeShader.SetFloat("deltaTime", Time.deltaTime);
        particleComputeShader.SetVector("gravity", new Vector3(0, -9.81f, 0));
        
        // 分派计算
        int threadGroups = Mathf.CeilToInt(particleCount / 64.0f);
        particleComputeShader.Dispatch(updateKernel, threadGroups, 1, 1);
    }
    
    void OnRenderObject()
    {
        // 使用Graphics.DrawProcedural渲染粒子
        particleMaterial.SetPass(0);
        Graphics.DrawProceduralNow(MeshTopology.Points, particleCount);
    }
    
    void OnDestroy()
    {
        if (particleBuffer != null)
        {
            particleBuffer.Release();
        }
    }
}
```

---

## 光照系统详解

### 实时光照

#### 1. 光源类型和计算
```csharp
public class LightingSystem : MonoBehaviour
{
    // 方向光计算
    public static Vector3 CalculateDirectionalLight(Light light, Vector3 worldPos, Vector3 normal)
    {
        Vector3 lightDir = -light.transform.forward;
        float intensity = light.intensity;
        Color lightColor = light.color;
        
        // Lambert漫反射
        float NdotL = Mathf.Max(0, Vector3.Dot(normal, lightDir));
        
        // 计算阴影衰减
        float shadowAttenuation = CalculateShadowAttenuation(light, worldPos);
        
        Vector3 diffuse = lightColor.linear * intensity * NdotL * shadowAttenuation;
        
        return diffuse;
    }
    
    // 点光源计算
    public static Vector3 CalculatePointLight(Light light, Vector3 worldPos, Vector3 normal)
    {
        Vector3 lightPos = light.transform.position;
        Vector3 lightDir = (lightPos - worldPos).normalized;
        float distance = Vector3.Distance(lightPos, worldPos);
        
        // 距离衰减
        float attenuation = CalculateDistanceAttenuation(distance, light.range);
        
        // Lambert漫反射
        float NdotL = Mathf.Max(0, Vector3.Dot(normal, lightDir));
        
        Vector3 diffuse = light.color.linear * light.intensity * NdotL * attenuation;
        
        return diffuse;
    }
    
    // 聚光灯计算
    public static Vector3 CalculateSpotLight(Light light, Vector3 worldPos, Vector3 normal)
    {
        Vector3 lightPos = light.transform.position;
        Vector3 lightDir = (lightPos - worldPos).normalized;
        Vector3 spotDir = -light.transform.forward;
        
        float distance = Vector3.Distance(lightPos, worldPos);
        float distanceAttenuation = CalculateDistanceAttenuation(distance, light.range);
        
        // 聚光灯角度衰减
        float cosAngle = Vector3.Dot(-lightDir, spotDir);
        float spotAttenuation = CalculateSpotAttenuation(cosAngle, light.spotAngle, light.innerSpotAngle);
        
        float NdotL = Mathf.Max(0, Vector3.Dot(normal, lightDir));
        
        Vector3 diffuse = light.color.linear * light.intensity * NdotL * distanceAttenuation * spotAttenuation;
        
        return diffuse;
    }
    
    static float CalculateDistanceAttenuation(float distance, float range)
    {
        // Unity的距离衰减公式
        float attenuation = 1.0f / (1.0f + 25.0f * (distance / range) * (distance / range));
        
        // 平滑衰减到0
        float fadeStart = 0.8f * range;
        if (distance > fadeStart)
        {
            float fadeRange = range - fadeStart;
            float fadeFactor = 1.0f - (distance - fadeStart) / fadeRange;
            attenuation *= fadeFactor * fadeFactor;
        }
        
        return attenuation;
    }
    
    static float CalculateSpotAttenuation(float cosAngle, float spotAngle, float innerSpotAngle)
    {
        float outerCos = Mathf.Cos(spotAngle * 0.5f * Mathf.Deg2Rad);
        float innerCos = Mathf.Cos(innerSpotAngle * 0.5f * Mathf.Deg2Rad);
        
        if (cosAngle < outerCos)
            return 0;
        
        if (cosAngle > innerCos)
            return 1;
        
        // 平滑过渡
        float t = (cosAngle - outerCos) / (innerCos - outerCos);
        return t * t;
    }
    
    static float CalculateShadowAttenuation(Light light, Vector3 worldPos)
    {
        // 阴影计算（简化版）
        if (!light.shadows.Equals(LightShadows.None))
        {
            // 实际应用中需要进行阴影贴图采样
            return SampleShadowMap(light, worldPos);
        }
        
        return 1.0f;
    }
    
    static float SampleShadowMap(Light light, Vector3 worldPos)
    {
        // 阴影贴图采样实现
        // 这里简化处理，实际需要：
        // 1. 将世界坐标转换到光源空间
        // 2. 采样深度纹理
        // 3. 比较深度值
        return 1.0f;
    }
}
```

### 全局光照(GI)

#### 1. 光照探针系统
```csharp
public class LightProbeSystem : MonoBehaviour
{
    public Transform[] probePositions;
    public LayerMask cullingMask = -1;
    
    void Start()
    {
        GenerateLightProbes();
    }
    
    void GenerateLightProbes()
    {
        // 创建光照探针组
        GameObject lightProbeGroup = new GameObject("Light Probe Group");
        LightProbeGroup probeGroup = lightProbeGroup.AddComponent<LightProbeGroup>();
        
        // 设置探针位置
        Vector3[] positions = new Vector3[probePositions.Length];
        for (int i = 0; i < probePositions.Length; i++)
        {
            positions[i] = probePositions[i].position;
        }
        
        probeGroup.probePositions = positions;
        
        // 烘焙光照探针
        BakeLightProbes();
    }
    
    void BakeLightProbes()
    {
        // 设置光照烘焙参数
        LightmapEditorSettings.maxAtlasSize = 1024;
        LightmapEditorSettings.textureResolution = 32;
        LightmapEditorSettings.enableAmbientOcclusion = true;
        
        // 开始烘焙
        Lightmapping.BakeAsync();
    }
    
    // 运行时光照探针插值
    public Color SampleLightProbes(Vector3 position, Vector3 normal)
    {
        // 获取光照探针数据
        SphericalHarmonicsL2 sh = RenderSettings.ambientProbe;
        LightProbes.GetInterpolatedProbe(position, null, out sh);
        
        // 计算球谐光照
        Color ambient = EvaluateSphericalHarmonics(sh, normal);
        
        return ambient;
    }
    
    Color EvaluateSphericalHarmonics(SphericalHarmonicsL2 sh, Vector3 normal)
    {
        // 球谐函数计算（简化版）
        // 实际计算需要完整的球谐基函数
        
        Vector3 color = Vector3.zero;
        
        // L0项（DC分量）
        color += sh[0, 0] * 0.282095f;
        color += sh[1, 0] * 0.282095f;
        color += sh[2, 0] * 0.282095f;
        
        // L1项（线性项）
        color += sh[0, 1] * (0.488603f * normal.y);
        color += sh[1, 1] * (0.488603f * normal.y);
        color += sh[2, 1] * (0.488603f * normal.y);
        
        color += sh[0, 2] * (0.488603f * normal.z);
        color += sh[1, 2] * (0.488603f * normal.z);
        color += sh[2, 2] * (0.488603f * normal.z);
        
        color += sh[0, 3] * (0.488603f * normal.x);
        color += sh[1, 3] * (0.488603f * normal.x);
        color += sh[2, 3] * (0.488603f * normal.x);
        
        return new Color(color.x, color.y, color.z, 1.0f);
    }
}
```

#### 2. 反射探针系统
```csharp
public class ReflectionProbeSystem : MonoBehaviour
{
    public int reflectionTextureSize = 128;
    public LayerMask cullingMask = -1;
    public bool enableBoxProjection = true;
    
    private ReflectionProbe reflectionProbe;
    private RenderTexture reflectionTexture;
    
    void Start()
    {
        SetupReflectionProbe();
    }
    
    void SetupReflectionProbe()
    {
        reflectionProbe = gameObject.AddComponent<ReflectionProbe>();
        
        // 基本设置
        reflectionProbe.resolution = reflectionTextureSize;
        reflectionProbe.cullingMask = cullingMask;
        reflectionProbe.clearFlags = ReflectionProbeClearFlags.Skybox;
        
        // 影响范围
        reflectionProbe.size = Vector3.one * 10f;
        reflectionProbe.center = Vector3.zero;
        
        // 投影设置
        if (enableBoxProjection)
        {
            reflectionProbe.boxProjection = true;
        }
        
        // 创建自定义反射贴图
        CreateCustomReflectionTexture();
        
        // 设置更新模式
        reflectionProbe.mode = ReflectionProbeMode.Realtime;
        reflectionProbe.refreshMode = ReflectionProbeRefreshMode.ViaScripting;
        
        // 手动渲染
        RenderReflectionProbe();
    }
    
    void CreateCustomReflectionTexture()
    {
        reflectionTexture = new RenderTexture(reflectionTextureSize, reflectionTextureSize, 16);
        reflectionTexture.dimension = UnityEngine.Rendering.TextureDimension.Cube;
        reflectionTexture.format = RenderTextureFormat.ARGB32;
        reflectionTexture.useMipMap = true;
        reflectionTexture.autoGenerateMips = true;
        
        reflectionProbe.customBakedTexture = reflectionTexture;
    }
    
    void RenderReflectionProbe()
    {
        // 手动渲染反射探针
        int renderID = reflectionProbe.RenderProbe();
        
        // 等待渲染完成
        StartCoroutine(WaitForProbeRender(renderID));
    }
    
    IEnumerator WaitForProbeRender(int renderID)
    {
        while (!reflectionProbe.IsFinishedRendering(renderID))
        {
            yield return null;
        }
        
        Debug.Log("Reflection probe rendering completed");
    }
    
    // 实时更新反射探针
    public void UpdateReflectionProbe()
    {
        if (reflectionProbe.mode == ReflectionProbeMode.Realtime)
        {
            RenderReflectionProbe();
        }
    }
    
    // 获取反射探针影响的渲染器
    public Renderer[] GetAffectedRenderers()
    {
        List<Renderer> affectedRenderers = new List<Renderer>();
        Bounds probeBounds = new Bounds(
            transform.position + reflectionProbe.center,
            reflectionProbe.size
        );
        
        Renderer[] allRenderers = FindObjectsOfType<Renderer>();
        
        foreach (Renderer renderer in allRenderers)
        {
            if (probeBounds.Intersects(renderer.bounds))
            {
                affectedRenderers.Add(renderer);
            }
        }
        
        return affectedRenderers.ToArray();
    }
    
    void OnDestroy()
    {
        if (reflectionTexture != null)
        {
            reflectionTexture.Release();
        }
    }
}
```

---

## 渲染优化策略

### 1. 批处理优化
```csharp
public class BatchingOptimization : MonoBehaviour
{
    [Header("静态批处理")]
    public bool enableStaticBatching = true;
    
    [Header("动态批处理")]
    public bool enableDynamicBatching = true;
    public int maxVertexCount = 300;
    
    [Header("GPU Instancing")]
    public bool enableGPUInstancing = true;
    public Material instancedMaterial;
    
    void Start()
    {
        SetupBatchingOptimizations();
    }
    
    void SetupBatchingOptimizations()
    {
        // 1. 静态批处理设置
        if (enableStaticBatching)
        {
            SetupStaticBatching();
        }
        
        // 2. 动态批处理设置
        if (enableDynamicBatching)
        {
            SetupDynamicBatching();
        }
        
        // 3. GPU Instancing设置
        if (enableGPUInstancing)
        {
            SetupGPUInstancing();
        }
    }
    
    void SetupStaticBatching()
    {
        // 收集静态对象
        List<GameObject> staticObjects = new List<GameObject>();
        
        MeshRenderer[] allRenderers = FindObjectsOfType<MeshRenderer>();
        foreach (MeshRenderer renderer in allRenderers)
        {
            if (renderer.gameObject.isStatic && CanBatch(renderer))
            {
                staticObjects.Add(renderer.gameObject);
            }
        }
        
        // 执行静态批处理
        if (staticObjects.Count > 1)
        {
            StaticBatchingUtility.Combine(staticObjects.ToArray(), this.gameObject);
            Debug.Log($"Static batching applied to {staticObjects.Count} objects");
        }
    }
    
    void SetupDynamicBatching()
    {
        // 动态批处理在Player Settings中设置
        // 这里检查是否符合动态批处理条件
        
        MeshRenderer[] renderers = FindObjectsOfType<MeshRenderer>();
        foreach (MeshRenderer renderer in renderers)
        {
            if (!renderer.gameObject.isStatic)
            {
                CheckDynamicBatchingCompatibility(renderer);
            }
        }
    }
    
    bool CheckDynamicBatchingCompatibility(MeshRenderer renderer)
    {
        MeshFilter meshFilter = renderer.GetComponent<MeshFilter>();
        if (meshFilter == null || meshFilter.mesh == null)
            return false;
        
        Mesh mesh = meshFilter.mesh;
        
        // 检查顶点数量
        if (mesh.vertexCount > maxVertexCount)
        {
            Debug.LogWarning($"Object {renderer.name} has too many vertices for dynamic batching: {mesh.vertexCount}");
            return false;
        }
        
        // 检查是否使用相同材质
        if (!CanBatch(renderer))
            return false;
        
        // 检查缩放
        if (renderer.transform.lossyScale != Vector3.one)
        {
            Debug.LogWarning($"Object {renderer.name} has non-uniform scale, cannot be dynamically batched");
            return false;
        }
        
        return true;
    }
    
    void SetupGPUInstancing()
    {
        // GPU Instancing示例
        if (instancedMaterial == null || !instancedMaterial.enableInstancing)
        {
            Debug.LogWarning("Material does not support GPU Instancing");
            return;
        }
        
        // 创建实例化渲染
        CreateInstancedRenderer();
    }
    
    void CreateInstancedRenderer()
    {
        int instanceCount = 1000;
        Matrix4x4[] matrices = new Matrix4x4[instanceCount];
        MaterialPropertyBlock propertyBlock = new MaterialPropertyBlock();
        
        // 生成实例矩阵
        for (int i = 0; i < instanceCount; i++)
        {
            Vector3 position = new Vector3(
                UnityEngine.Random.Range(-50f, 50f),
                0,
                UnityEngine.Random.Range(-50f, 50f)
            );
            
            matrices[i] = Matrix4x4.TRS(position, Quaternion.identity, Vector3.one);
        }
        
        // 设置per-instance属性
        Vector4[] colors = new Vector4[instanceCount];
        for (int i = 0; i < instanceCount; i++)
        {
            colors[i] = UnityEngine.Random.ColorHSV();
        }
        
        propertyBlock.SetVectorArray("_Color", colors);
        
        // 渲染实例
        Mesh mesh = GetComponent<MeshFilter>().mesh;
        Graphics.DrawMeshInstanced(mesh, 0, instancedMaterial, matrices, instanceCount, propertyBlock);
    }
    
    bool CanBatch(MeshRenderer renderer)
    {
        // 检查批处理兼容性
        
        // 1. 检查材质
        if (renderer.material == null)
            return false;
        
        // 2. 检查是否有MaterialPropertyBlock
        if (renderer.HasPropertyBlock())
            return false;
        
        // 3. 检查是否有多个材质
        if (renderer.materials.Length > 1)
            return false;
        
        // 4. 检查Shader兼容性
        Shader shader = renderer.material.shader;
        if (shader.name.Contains("Transparent") || shader.name.Contains("Cutout"))
            return false;
        
        return true;
    }
}
```

### 2. LOD和剔除优化
```csharp
public class LODAndCullingOptimization : MonoBehaviour
{
    [Header("LOD设置")]
    public LODGroup lodGroup;
    public float[] lodScreenRelativeTransitionHeights = { 0.6f, 0.3f, 0.1f };
    
    [Header("遮挡剔除")]
    public bool enableOcclusionCulling = true;
    public Occluder[] occluders;
    
    void Start()
    {
        SetupLODSystem();
        SetupOcclusionCulling();
    }
    
    void SetupLODSystem()
    {
        if (lodGroup == null)
            lodGroup = gameObject.AddComponent<LODGroup>();
        
        // 获取LOD渲染器
        Renderer[] lod0Renderers = GetLODRenderers(0);
        Renderer[] lod1Renderers = GetLODRenderers(1);
        Renderer[] lod2Renderers = GetLODRenderers(2);
        
        // 创建LOD数组
        LOD[] lods = new LOD[]
        {
            new LOD(lodScreenRelativeTransitionHeights[0], lod0Renderers),
            new LOD(lodScreenRelativeTransitionHeights[1], lod1Renderers),
            new LOD(lodScreenRelativeTransitionHeights[2], lod2Renderers),
            new LOD(0.01f, new Renderer[0]) // 完全剔除
        };
        
        lodGroup.SetLODs(lods);
        lodGroup.RecalculateBounds();
        
        // 设置LOD偏移
        lodGroup.size = CalculateLODSize();
        
        // 启用LOD交叉淡化
        lodGroup.fadeMode = LODFadeMode.CrossFade;
        lodGroup.animateCrossFading = true;
    }
    
    Renderer[] GetLODRenderers(int lodLevel)
    {
        // 根据LOD级别获取对应的渲染器
        Transform lodParent = transform.Find($"LOD{lodLevel}");
        if (lodParent == null)
            return new Renderer[0];
        
        return lodParent.GetComponentsInChildren<Renderer>();
    }
    
    float CalculateLODSize()
    {
        // 计算对象的包围盒大小
        Bounds bounds = new Bounds(transform.position, Vector3.zero);
        
        Renderer[] renderers = GetComponentsInChildren<Renderer>();
        foreach (Renderer renderer in renderers)
        {
            bounds.Encapsulate(renderer.bounds);
        }
        
        return bounds.size.magnitude;
    }
    
    void SetupOcclusionCulling()
    {
        if (!enableOcclusionCulling)
            return;
        
        // 设置遮挡体
        foreach (Occluder occluder in occluders)
        {
            if (occluder == null)
                continue;
            
            // 确保遮挡体正确设置
            occluder.enabled = true;
        }
        
        // 设置相机遮挡剔除
        Camera[] cameras = FindObjectsOfType<Camera>();
        foreach (Camera camera in cameras)
        {
            camera.useOcclusionCulling = true;
        }
        
        // 创建动态遮挡剔除
        SetupDynamicOcclusionCulling();
    }
    
    void SetupDynamicOcclusionCulling()
    {
        // 自定义遮挡剔除系统
        StartCoroutine(DynamicOcclusionCullingUpdate());
    }
    
    IEnumerator DynamicOcclusionCullingUpdate()
    {
        while (true)
        {
            Camera mainCamera = Camera.main;
            if (mainCamera != null)
            {
                PerformCustomOcclusionCulling(mainCamera);
            }
            
            yield return new WaitForSeconds(0.1f); // 每0.1秒更新一次
        }
    }
    
    void PerformCustomOcclusionCulling(Camera camera)
    {
        Renderer[] allRenderers = FindObjectsOfType<Renderer>();
        
        foreach (Renderer renderer in allRenderers)
        {
            if (IsOccluded(renderer, camera))
            {
                renderer.enabled = false;
            }
            else
            {
                renderer.enabled = true;
            }
        }
    }
    
    bool IsOccluded(Renderer target, Camera camera)
    {
        // 简化的遮挡检测
        Vector3 cameraPos = camera.transform.position;
        Vector3 targetPos = target.bounds.center;
        
        // 射线检测
        Vector3 direction = (targetPos - cameraPos).normalized;
        float distance = Vector3.Distance(cameraPos, targetPos);
        
        RaycastHit hit;
        if (Physics.Raycast(cameraPos, direction, out hit, distance))
        {
            // 检查击中的是否是目标对象
            return hit.renderer != target;
        }
        
        return false;
    }
    
    // 距离剔除
    void SetupDistanceCulling()
    {
        DistanceCullingManager cullingManager = Camera.main.gameObject.AddComponent<DistanceCullingManager>();
        cullingManager.maxRenderDistance = 100f;
        cullingManager.cullingLayers = LayerMask.GetMask("Default");
    }
}

public class DistanceCullingManager : MonoBehaviour
{
    public float maxRenderDistance = 100f;
    public LayerMask cullingLayers = -1;
    
    private Camera targetCamera;
    private Dictionary<Renderer, float> originalRenderDistances;
    
    void Start()
    {
        targetCamera = GetComponent<Camera>();
        originalRenderDistances = new Dictionary<Renderer, float>();
        
        // 记录原始渲染距离
        Renderer[] allRenderers = FindObjectsOfType<Renderer>();
        foreach (Renderer renderer in allRenderers)
        {
            originalRenderDistances[renderer] = renderer.enabled ? maxRenderDistance : 0f;
        }
        
        StartCoroutine(DistanceCullingUpdate());
    }
    
    IEnumerator DistanceCullingUpdate()
    {
        while (true)
        {
            PerformDistanceCulling();
            yield return new WaitForSeconds(0.1f);
        }
    }
    
    void PerformDistanceCulling()
    {
        Vector3 cameraPos = targetCamera.transform.position;
        
        foreach (var kvp in originalRenderDistances)
        {
            Renderer renderer = kvp.Key;
            if (renderer == null)
                continue;
            
            // 检查层级
            if ((cullingLayers & (1 << renderer.gameObject.layer)) == 0)
                continue;
            
            float distance = Vector3.Distance(cameraPos, renderer.bounds.center);
            
            // 根据距离启用/禁用渲染器
            renderer.enabled = distance <= maxRenderDistance;
        }
    }
}
```

---

## 常见面试问题

### 1. **Q: Built-in渲染管线和URP的主要区别？**
```
A: 核心差异：
1. 架构设计：
   - Built-in：固定管线，有限自定义
   - URP：可编程管线，完全自定义

2. 性能特性：
   - Built-in：多Pass渲染，Draw Call较多
   - URP：Single Pass渲染，SRP Batcher优化

3. 平台支持：
   - Built-in：主要针对PC/主机
   - URP：跨平台优化，移动端友好

4. 功能特性：
   - Built-in：功能完整但老旧
   - URP：现代化功能，持续更新

选择依据：
- 新项目 → URP
- 移动端 → URP
- 需要高度自定义 → Custom SRP
```

### 2. **Q: SRP Batcher的工作原理？**
```
A: SRP Batcher原理：
1. 数据组织：
   - UnityPerMaterial CBUFFER：材质属性
   - UnityPerDraw CBUFFER：Transform数据
   - 将相同shader的对象批处理

2. 渲染流程：
   // GPU端数据布局
   CBUFFER_START(UnityPerMaterial)
       float4 _BaseColor;
       float _Metallic;
   CBUFFER_END
   
   CBUFFER_START(UnityPerDraw)
       float4x4 unity_ObjectToWorld;
   CBUFFER_END

3. 性能优势：
   - 减少CPU到GPU的数据传输
   - 降低Draw Call数量
   - 提高GPU利用率

4. 兼容性要求：
   - Shader必须兼容SRP Batcher
   - 避免运行时修改材质属性
   - 使用MaterialPropertyBlock
```

### 3. **Q: 光照烘焙和实时光照的区别？**
```
A: 光照类型对比：
1. 烘焙光照（Baked Lighting）：
   - 预计算光照信息
   - 存储在光照贴图中
   - 性能消耗低，质量高
   - 静态场景，无法实时变化

2. 实时光照（Realtime Lighting）：
   - 运行时计算光照
   - 动态变化，交互性强
   - 性能消耗高
   - 支持动态对象

3. 混合光照（Mixed Lighting）：
   - 结合烘焙和实时的优势
   - 静态对象用烘焙光照
   - 动态对象用实时光照

实现策略：
// 设置光源模式
light.lightmapBakeType = LightmapBakeType.Baked;    // 烘焙
light.lightmapBakeType = LightmapBakeType.Realtime; // 实时
light.lightmapBakeType = LightmapBakeType.Mixed;    // 混合
```

### 4. **Q: 渲染管线的剔除阶段都有哪些？**
```
A: 剔除类型：
1. 视锥剔除（Frustum Culling）：
   - 剔除相机视锥外的对象
   - 使用包围盒快速检测
   - CPU端执行

2. 遮挡剔除（Occlusion Culling）：
   - 剔除被其他对象遮挡的对象
   - 需要预计算遮挡数据
   - CPU端执行

3. 背面剔除（Backface Culling）：
   - 剔除背向相机的三角形
   - GPU端执行
   - 节省像素填充率

4. 距离剔除（Distance Culling）：
   - 剔除超出渲染距离的对象
   - 自定义实现
   - LOD系统的一部分

实现示例：
// 视锥剔除
Plane[] planes = GeometryUtility.CalculateFrustumPlanes(camera);
bool isVisible = GeometryUtility.TestPlanesAABB(planes, bounds);
```

### 5. **Q: GPU Instancing和Static Batching的适用场景？**
```
A: 批处理选择：
1. Static Batching：
   - 适用场景：大量相同材质的静态对象
   - 优势：减少Draw Call，无顶点限制
   - 劣势：增加内存使用，对象必须静态

2. Dynamic Batching：
   - 适用场景：小网格的动态对象（<300顶点）
   - 优势：对象可以移动
   - 劣势：有顶点限制，CPU开销

3. GPU Instancing：
   - 适用场景：大量相同Mesh的对象
   - 优势：高效渲染大量实例
   - 劣势：需要Shader支持，有实例数限制

选择策略：
// 静态环境 → Static Batching
StaticBatchingUtility.Combine(objects, root);

// 大量相同对象 → GPU Instancing
Graphics.DrawMeshInstanced(mesh, 0, material, matrices);

// 小动态对象 → Dynamic Batching
// 在Player Settings中启用
```

---

*这份文档深入讲解了Unity渲染系统的各个方面，从基础管线到高级优化技术，适合深度技术面试准备。*